宏流程 v2 设计草案（拖动不松手 + 返回 + 悬停后松手）
===========================================

目标
----
在“用户先指定拖动坐标（录制起点/终点）”的前提下，通过无障碍宏实现更精细的序列：

1) 点击按钮中心  
2) 延迟 10ms  
3) 拖动（录制起点 → 录制终点，但在终点不松手）  
4) 延迟 10ms  
5) 执行全局返回 `GLOBAL_ACTION_BACK`  
6) 在终点继续按住悬停 500ms  
7) 松手结束

现状与差距
---------
- 当前实现为“录制结束后移除 overlay，然后延迟 1s，只执行一次拖动手势并结束”（见 `TODO.md` 第 11 条）。
- v2 需要把拖动拆成“可继续的笔画（按住不松手）”与“继续/松手”的两阶段，并在两阶段之间插入一次 `GLOBAL_ACTION_BACK`。

关键技术点（Android 无障碍手势）
------------------------------
`dispatchGesture` 的手势由 `GestureDescription` + `StrokeDescription` 表示。

- 若要“拖到终点但不松手”，通常需要在第一段笔画上启用 `willContinue=true`。
- 若要“终点悬停 500ms 然后松手”，通常需要在下一次 `dispatchGesture` 中用 `continueStroke(...)` 续接同一根“虚拟手指”，并在续接段把 `willContinue=false`（结束即抬起）。

可行性风险（需要先做验证）
------------------------
1) 不同系统/厂商对“继续笔画”的支持存在差异；可能出现：
   - 继续失败（第二段无法续接）
   - 第一段完成即抬起（`willContinue` 失效）
2) 在“按住不松手”的期间执行 `performGlobalAction(GLOBAL_ACTION_BACK)` 可能触发系统对当前注入手势的取消，从而等效抬起/释放。
3) 即便系统层能维持按住，目标应用在界面返回/窗口变化时可能仍会收到 `ACTION_CANCEL`（表现为释放）。

建议的实现顺序（对应 TODO.md 第 12 条）
-------------------------------------
1) 先做最小验证：
   - 仅验证“拖动到终点不松手 → 悬停 500ms → 松手”是否稳定（不插入返回）
2) 再验证插入返回：
   - “拖动不松手 → 执行 `GLOBAL_ACTION_BACK` → 悬停 → 松手”
3) 最后串起完整宏：
   - “点击按钮中心 → 10ms → 拖动不松手 → 10ms → 返回 → 悬停 → 松手”

失败/回退策略（建议）
-------------------
- 任一步 `dispatchGesture` 回调 `onCancelled` 或 `dispatchGesture` 返回 false：
  - 立即结束本轮、清理 overlay、关闭开关并记录失败原因（日志即可）
- 如发现“返回导致按住失效”：
  - 允许降级为“拖动后松手 → 返回”（即回到 v1/现状思路），并在 TODO 中保留可切换方案

